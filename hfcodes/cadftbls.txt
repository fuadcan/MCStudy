/**
@@ THIS PROGRAM COMPUTE SOME STATISTICS OF TABLE 10,11,14 and more OF PESARAN, 	@@
@@ " A SIMPLE PANEL UNIT ROOT TEST UNDER CROSS SECTION DEPENDENCE"     		    @@
@@  FEBRUARY 2006                                                      		    @@
@@  								       		                                @@
@@  IT IS NECESSARY TO MODIFY DIRECTORY OF EXCEL FILE                           @@
@@   "real_exchange_7398.xls",                                                  @@         
@@  IN THE FIRST LINE OF THE PROGRAM.                                           @@
@@                                                                              @@
@@  ALSO A SIMPLE CODE TO COMPUTE CD TEST STATISTIC IS FOUND AT THE             @@
@@  END OF THIS FILE. THIS IS ONLY FOR BALANCED PANEL DATA, AND                 @@
@@  REQUIRE RESIDUALS AS INPUTS.                                                @@
@@                                                                              @@
@@  It would be appreciated if one could acknowledge the use of code            @@
@@  in his/er research.                                                         @@
@@                                                                              @@
@@    Takashi Yamagata 13 March 06                                              @@
**/

/***********************************************************************/
/** Loading the data, Please change the directory of excel data file **/
/***********************************************************************/

/*rer100=xlsreadm("F:\\DAE\\TY228\\Gauss6.0\\0myproc\\CADFgauss6\\real_exchange_7398.xls","b2:r105",1,"");*/
/*rer44=xlsreadm("F:\\DAE\\TY228\\Gauss6.0\\0myproc\\CADFgauss6\\real_exchange_7398.xls","b58:r105",1,"");*/

/*
file_name = "real_exchange_7398.xls";
cell_range = "b2:r105";
sheet_num = 1;
vls = "";

rer100 = xlsReadM(file_name, cell_range, sheet_num, vls);
*/

load rer100[100,20]=deneme1.csv;


maxp=3;case=2;var_mat=rer100;
t=rows(rer100)-maxp-1;n=cols(rer100);

/*OUTPUT FILE="nanay.txt" RESET;*/


/***********************************************************************/
/** Reproduce Left Panel of Table 10 of Pesaran (2006) **/
/***********************************************************************/
"";
"Table 10: CD test statistics: T=100";

/* firstly obtain residuals of ADF(p) regressions */
/* which is "d" below. See top of IPSmarch06.prc file */
/* for details in using this procedure                */
{a,b,c,d}=ips(var_mat,maxp,case);

/* compute CD test statistics for each p */
i=1;
do while i<=maxp+1;
    res_p_mat=d[1+(i-1)*t:(i)*t,.];
    {cd_p,lm_p}=cdlm(res_p_mat);
    format /rd 5,2;
    "p=";;i-1;;":";;cd_p;
    i=i+1;
endo;

/***********************************************************************/
/** Reproduce Left Panel of Table 11 of Pesaran (2006) **/
/***********************************************************************/
"";    
"----------------------------------------";
"Table 11: CIPS test statistics: T=100";
/* See top of CIPSmarch06.prc file */
/* for details in using this procedure */
/*output on;*/
{a2,b2,c2,d2}=cips(var_mat,maxp,case);
/*output off;*/
/***********************************************************************/
/** Reproduce Top Left Figures of Table 14 of Pesaran (2006) **/
/***********************************************************************/
k=1;
"";    
"----------------------------------------";
"Table 14: Moon and Perron test statistics: T=103,k=1";
/* See top of PU_MP04.prc file */
/* for details in using this procedure */
{tstarab}=PU_MP04(var_mat,k,case);

kset={1,4,6};

/***********************************************************************/
/* Bai and Ng (2002) Procedure to Estimate the Number of Factors */
/**********************************************************************/
/* See top of BaiNg02.prc file */
/* for details in using this procedure */
d_data=rer100-lag(rer100);
xmat=d_data[2:rows(d_data),.];

/*******/
result={};
i=1;
do while i<=rows(kset);
kmax=kset[i];
{nb,icmat}=bai02(xmat,kmax);
result=result~nb;
i=i+1;
endo;
"Change of 17 OCED real exchange rate, T=103";
"Estimated number of factors ";
"by using information criteria proposed by Bai and Ng (2002)";
top="maxk: "~ftocv(kset',1,0);
top2={"---","---","---","---"};
top=top|top2';
icname={"PC1","PC2","PC3","IC1","IC2","IC3"};
$ top|(icname~ftocv(result,1,0));

format /rd 10,7;

/************************************************************************/
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/* 			procedures follows				*/
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/************************************************************************/

/*output off;*/

/*************************************************************************/
/* THIS VERSION: 13/03/06                                               **/
/* COMPUTE CIPS(P) AND CIPS*(P) STATISTICS IN M.H.PESARAN               **/
/* " A SIMPLE PANEL UNIT ROOT TEST UNDER CROSS SECTION DEPENDENCE"      **/
/*  FEBRUARY 2006                                                       **/
/* NOTE:                                                                **/
/* Please report any problems you might have, to: ty228@cam.ac.uk       **/
/*                                                                      **/
/* {CIPSmat,cadf_p_mat,cadfs_p_mat,res_p_mat}=cips(var_mat,maxp,case)   **/
/* <<INPUTS>>                                                           **/
/* var_mat (T x N) matrix                                               **/
/* N            : number of cross section dimension                     **/
/* T		: number of observations for i's                            **/
/* maxp (more than or equal to zero) : maximum number of (ADF) lag order**/
/*                                    eg. maxp=0: CADF==CDF             **/
/* case=1: no intercept nor trend                                       **/
/* case=2: with intercept                                               **/
/* case=3: with intercept and trend                                     **/
/* <<OUTPUTS>>                                                          **/
/* CIPSmat: (maxp+1) x 2 matrix, first column reports                   **/
/*          CIPS(p) and second column reports CIPS*(p)                  **/
/*          for p=0,1,...,maxp in ascending order                       **/
/*     -CIPS(p) statistic is defined as simple average of               **/
/*       CADF(p)_i statistics                                           **/
/*     -CIPS*(p) statistic is defined as simple average of              **/
/*       CADF*(p)_i statistics, which is truncated version of CADF_i.   **/   
/*                                                                      **/   
/* cadf_p_mat: a N x (maxp+1) matrix, reports all CADF(p)_i statistics  **/   
/* cadfs_p_mat: a N x (maxp+1) matrix, reports all CADF*(p)_i statistics**/
/* res_p_mat: a (maxp+1) set of						                    **/ 
/*		T-(maxp+1) x N matrix of residuals of CADF(p)_i regressions	    **/
/*              concatenated vertically, from the top p=0,p=1,,,p=maxp  **/    
/*                                                                      **/   
/* NB: Appropriate critical values for CIPS statistic are found         **/
/*  are in Table 2 in Pesaran (2006)                                    **/    
/*                                                                      **/
/* NOTEs: Default setting is to print the results. It can be            **/
/*       suppressed by choosing "outpt=0" below (7th-line of the code   **/
/* Takashi Yamagata, 13 March2006                                       **/
/*                                                                      **/
/*************************************************************************/
proc(4)=cips(var_mat,maxp,case);
local outpt,n,t,tlag,var_mat_1,Dvar_mat_temp,Dvar_mat,Dvar_CSM,var_1_CSM;
local tt,y,z,hi,x,h,k1,k2,bvec,sevec,t_vec_cce,t_bar,i,c_p,temp;
local trncl,truncu,trnc1,cadf_p,cadf_ps,cips_p_mat,cips_p,cips_ps;
local cadf_p_mat,cadfs_p_mat,idvec,lgorder,res_p_mat,res_p;


/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outpt=1;/* 1: reports ourput, 0:supress the output */
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outwidth 256;

t=rows(var_mat);
n=cols(var_mat);
tlag=maxp+1;

var_mat_1=lag(var_mat);
Dvar_mat_temp=var_mat-var_mat_1;
    var_mat_1=var_mat_1[tlag+1:t,.];
    Dvar_mat=Dvar_mat_temp[tlag+1:t,.];

Dvar_CSM=meanc(Dvar_mat');
var_1_CSM=meanc(var_mat_1');

tt=t-tlag;

/*************/
y=vec(Dvar_mat);
Hi=Dvar_CSM~var_1_CSM;
x=vec(var_mat_1);

/****/
if case==1;k1=-6.12;k2=4.16;
elseif case==2;Z=ones(n*tt,1);k1=-6.19;k2=2.61;
elseif case==3;Z=ones(n*tt,1)~(ONES(N,1).*.seqa(1,1,tt));k1=-6.42;k2=1.70;
else;"please choose the 'case' only from 1,2, or 3";end;
endif;

/**************** ESTIMATION ****************/
c_p=0;
cips_p_mat={};
cadf_p_mat={};
cadfs_p_mat={};
res_p_mat={};
do while c_p<=maxp;

if c_p>0;
    temp=(Dvar_mat_temp[tlag+1-c_p:t-c_p,.]);
    Hi=Hi~meanc(temp'); 
    x=x~vec(temp);
endif;

/*************/
if case==1;H=(ONES(N,1).*.Hi);
else;H=Z~(ONES(N,1).*.Hi);
endif;

/*** MGCCE ****/
{bvec,sevec,t_vec_cce,res_p}=mgsimple(y,x~h,n,tt);

trncl=k1*(t_vec_cce[.,1].<k1);truncu=k2*(t_vec_cce[.,1].>k2);
trnc1=(t_vec_cce[.,1].>k1).*(t_vec_cce[.,1].<k2);

cadf_p = t_vec_cce[.,1];
cadf_ps = (t_vec_cce[.,1].*trnc1+trncl+truncu);

cips_p=meanc(cadf_p);
cips_ps=meanc(cadf_ps);

if outpt==1;
format /rd 2,0;
"@@@@@@@@@@@@@@@@@@@ CADF(";;C_P;;") @@@@@@@@@@@@@@@@@@@@";
format /rd 2,0;
"CIPS TEST: CASE";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 5,0;
"N=";;n;;", T=";;tt;;", (";;t;;"data points used)";
format /rd 8,3;
"   CIPS            :";;cips_p;
"   CIPS*(truncated):";;cips_ps;
"* Truncation is done for CADF_i in such a way that" ;
format /rd 1,2;
"when CADF_i<k1, CADF_i=k1 and when CADF_i>k2, CADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
"Appropriate critical values are in Table 2, Pesaran (2006).";
"-------------------------------------------------------";
"";
endif;
cips_p_mat=cips_p_mat|(cips_p~cips_ps);
cadf_p_mat=cadf_p_mat~cadf_p;
cadfs_p_mat=cadfs_p_mat~cadf_ps;

res_p_mat=res_p_mat|res_p;

    c_p=c_p+1;
endo;

if outpt==1;
format /rd 8,0;
idvec=ftocv(seqa(1,1,n),1,0);
lgorder="id/p"~ftocv(seqa(0,1,maxp+1)',1,0);

format /rd 2,0;
"";
"*****************************************************";
"CADF_i(p) Statistics: Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(cadf_p_mat,1,3)));
"";
"Appropriate critical values are in Table 1, Pesaran (2006).";
"*****************************************************";
format /rd 2,0;
"CADF*_i(p) Statistics (truncated): Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT and TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(cadfs_p_mat,1,3)));
"* Truncation is done for CADF_i in such a way that" ;
format /rd 1,2;
"when CADF_i<k1, CADF_i=k1 and when CADF_i>k2, CADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
"Appropriate critical values are in Table 1, Pesaran (2006).";
endif;

format /rd 16,8;
retp(cips_p_mat,cadf_p_mat,cadfs_p_mat,res_p_mat);
endp;

/*** OLS regression for each cross section unit ****/
proc(4)=mgsimple(y,x,n,t);
local bvec,sevec,tvec,i,y_i,x_i,beta_i,e_i,zig2,se_i,t_i,res_mat;
bvec=zeros(n,cols(x));
sevec=zeros(n,cols(x));
tvec=zeros(n,cols(x));
res_mat={};
i=1;
do while i<=n;
    y_i=y[1+(i-1)*t:(i)*t,.];
    x_i=x[1+(i-1)*t:(i)*t,.];
    beta_i=y_i/x_i;
    e_i=y_i-x_i*beta_i;
    zig2=e_i'e_i/(T-cols(x));
    se_i=sqrt(diag(zig2*invpd(x_i'x_i)));
    t_i=beta_i./se_i;

    bvec[i,.]=beta_i';
    sevec[i,.]=se_i';
    tvec[i,.]=t_i';
    res_mat=res_mat~e_i;

i=i+1;
endo;

retp(bvec,sevec,tvec,res_mat);
endp;
/*************************************************************************/
/* THIS VERSION: 13/03/06                                               **/
/* COMPUTE tbar(P) (AND tbar*(P)) STATISTICS IN IM, PESARAN, SHIN (2003)**/
/* "Testing for unit roots in heterogeneous panels", Journal of         **/
/*  Econometrics 115, 53-74.                                            **/
/* For the truncated version, see Pesaran (2006),                       **/
/* " A SIMPLE PANEL UNIT ROOT TEST UNDER CROSS SECTION DEPENDENCE"      **/
/*  FEBRUARY 2006                                                       **/
/* NOTE:                                                                **/
/* Please report any problems you might have, to: ty228@econ.cam.ac.uk  **/
/*                                                                      **/
/* {tbarmat,adf_p_mat,adfs_p_mat,res_p_mat}=ips(var_mat,maxp,case);     **/
/*                                                                      **/
/* <<INPUTS>>                                                           **/
/* var_mat (T x N) matrix                                               **/
/* N            : number of cross section dimension                     **/
/* T		: number of observations for i's                            **/
/* maxp (more than or equal to zero) : maximum number of (ADF) lag order**/
/*                                    eg. maxp=0: ADF==DF               **/
/* case=1: no intercept nor trend                                       **/
/* case=2: with intercept                                               **/
/* case=3: with intercept and trend                                     **/
/* <<OUTPUTS>>                                                          **/
/* tbarmat: (maxp+1) x 2 matrix, first column reports                   **/
/*          tbar(p) and second column reports tbar*(p)                  **/
/*          for p=0,1,...,maxp in ascending order                       **/
/*     -tbar(p) statistic is defined as simple average of               **/
/*       adf(p)_i statistics                                            **/
/*     -tbar*(p) statistic is defined as simple average of              **/
/*       adf*(p)_i statistics, which is truncated version of adf(p)_i.  **/
/*    Notes: For a discussion about the truncation, See Pesaran (2006), **/
/*      " A Simple Panel Unit Root Test Under Cross Section Dependence" **/
/*                                                                      **/   
/* adf_p_mat: a N x (maxp+1) matrix, reports all ADF(p)_i statistics    **/   
/* adfs_p_mat: a N x (maxp+1) matrix, reports all ADF*(p)_i statistics  **/   
/* res_p_mat: a (maxp+1) set of						                    **/ 
/*		T-(maxp+1) x N matrix of residuals of  ADF(p)_i regressions	    **/
/*              concatenated vertically, from the top p=0,p=1,,,p=maxp  **/    
/*                                                                      **/   
/* IPS is sqrt(N)*(TBAR - E(TBAR))/sqrt(Var(TBAR)).                     **/
/* Appropriate E(TBAR) and Var(TBAR) are found in                       **/
/* Table 3 of Im,Pesaran,Shin (2003)                                    **/
/* NOTEs: Default setting is to print the results. It can be            **/
/*       suppressed by choosing "outpt=0" below (7th-line of the code   **/
/* Takashi Yamagata, 13 March 2006                                        **/
/*                                                                      **/
/*************************************************************************/
proc(4)=ips(var_mat,maxp,case);
local outpt,n,t,tlag,var_mat_1,Dvar_mat_temp,Dvar_mat;
local tt,y,z,x,xx,k1,k2,bvec,sevec,t_vec,t_bar,i,c_p,temp;
local trncl,truncu,trnc1,adf_p,adf_ps,tbar_p_mat,tbar_p,tbar_ps;
local adf_p_mat,adfs_p_mat,idvec,lgorder,res_p_mat,res_p;


/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outpt=0;/* 1: reports ourput, 0:supress the output */
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outwidth 256;

t=rows(var_mat);
n=cols(var_mat);
tlag=maxp+1;

var_mat_1=lag(var_mat);
Dvar_mat_temp=var_mat-var_mat_1;
    var_mat_1=var_mat_1[tlag+1:t,.];
    Dvar_mat=Dvar_mat_temp[tlag+1:t,.];

tt=t-tlag;

/*************/
y=vec(Dvar_mat);
x=vec(var_mat_1);

/****/
if case==1;k1=-6.12;k2=4.16;
elseif case==2;Z=ones(n*tt,1);k1=-6.19;k2=2.61;
elseif case==3;Z=ones(n*tt,1)~(ONES(N,1).*.seqa(1,1,tt));k1=-6.42;k2=1.70;
else;"please choose the 'case' only from 1,2, or 3";end;
endif;

/**************** ESTIMATION ****************/
c_p=0;
tbar_p_mat={};
adf_p_mat={};
adfs_p_mat={};
res_p_mat={};
do while c_p<=maxp;

if c_p>0;
    temp=(Dvar_mat_temp[tlag+1-c_p:t-c_p,.]);
    x=x~vec(temp);
endif;

/*************/
if case==1;xx=x;
else;xx=x~Z;
endif;

/*** MGCCE ****/
{bvec,sevec,t_vec,res_p}=mgsimple(y,xx,n,tt);

trncl=k1*(t_vec[.,1].<k1);truncu=k2*(t_vec[.,1].>k2);
trnc1=(t_vec[.,1].>k1).*(t_vec[.,1].<k2);

adf_p = t_vec[.,1];
adf_ps = (t_vec[.,1].*trnc1+trncl+truncu);

tbar_p=meanc(adf_p);
tbar_ps=meanc(adf_ps);

if outpt==1;
format /rd 2,0;
"@@@@@@@@@@@@@@@@@@@ ADF(";;C_P;;") @@@@@@@@@@@@@@@@@@@@";
format /rd 2,0;
"tbar STATISTIC FOR IPS(P): CASE";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 5,0;
"N=";;n;;", T=";;tt;;", (";;t;;"data points used)";
format /rd 8,3;
"   TBAR(P)            :";;tbar_p;
"   TBAR(P)*(truncated):";;tbar_ps;
format /rd 1,2;
"*Truncation is done for ADF_i in such a way that";
"when ADF_i<k1, ADF_i=k1 and when ADF_i>k2, ADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
"IPS is sqrt(N)*(TBAR - E(TBAR))/sqrt(Var(TBAR)).";
"Appropriate E(TBAR) and Var(TBAR) are found in Table 3 of Im,Pesaran,Shin (2003).";
"-------------------------------------------------------";
"";
endif;
tbar_p_mat=tbar_p_mat|(tbar_p~tbar_ps);
adf_p_mat=adf_p_mat~adf_p;
adfs_p_mat=adfs_p_mat~adf_ps;
res_p_mat=res_p_mat|res_p;

    c_p=c_p+1;
endo;

if outpt==1;
format /rd 8,0;
idvec=ftocv(seqa(1,1,n),1,0);
lgorder="id/p"~ftocv(seqa(0,1,maxp+1)',1,0);

format /rd 2,0;
"";
"*****************************************************";
"ADF_i(p) Statistics: Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(adf_p_mat,1,3)));
"";
"*****************************************************";
format /rd 2,0;
"ADF*_i(p) Statistics (truncated): Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT and TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(adfs_p_mat,1,3)));
format /rd 1,2;
"*Truncation is done for ADF_i in such a way that";
"when ADF_i<k1, ADF_i=k1 and when ADF_i>k2, ADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
endif;

format /rd 16,8;
retp(tbar_p_mat,adf_p_mat,adfs_p_mat,res_p_mat);
endp;

/*** OLS regression for each cross section unit ****/
proc(4)=mgsimple(y,x,n,t);
local bvec,sevec,tvec,i,y_i,x_i,beta_i,e_i,zig2,se_i,t_i,res_mat;
bvec=zeros(n,cols(x));
sevec=zeros(n,cols(x));
tvec=zeros(n,cols(x));
res_mat={};
i=1;
do while i<=n;
    y_i=y[1+(i-1)*t:(i)*t,.];
    x_i=x[1+(i-1)*t:(i)*t,.];
    beta_i=y_i/x_i;
    e_i=y_i-x_i*beta_i;
    zig2=e_i'e_i/(T-cols(x));
    se_i=sqrt(diag(zig2*invpd(x_i'x_i)));
    t_i=beta_i./se_i;

    bvec[i,.]=beta_i';
    sevec[i,.]=se_i';
    tvec[i,.]=t_i';
    res_mat=res_mat~e_i;

i=i+1;
endo;

retp(bvec,sevec,tvec,res_mat);
endp;
/********************************************************************/
/* This is a gauss procedure to compute Moon and Perron (2004),     */
/* "TESTING FOR A UNIT ROOT IN PANELS WITH DYNAMIC FACTORS",        */
/* Journal of Econometrics 122, 81-126.                             */
/*                                                                  */
/* This code is heavily based on the Matlab code by                 */
/* Moon & Perron 2004, last updated June 25 2004.                   */
/*								                                    */
/* {testvec}=PU_MP04(y,m,case);	                                    */
/*                                                                  */
/*  <<INPUT>>                                                       */
/*  y: (T+1 x N) matrix                                             */
/*  m: number of factors (estimated beforehand or known)            */
/*  case:  1 or 2: fixed effects no trend, or 3: deterministic trend*/
/*                                                                  */
/*  <<OUTPUT>>                                                      */
/*  testvec: a (3 x 1) vector, (m,tstara,tstarb)'                   */
/*          tstara and tstarb are defined in p.92 for case 1 & 2.   */
/*                                                                  */
/*  NB:This code uses Andrews and Monahan (1992) bandwidth estimator*/
/* NOTEs: Default setting is to print the results. It can be        */
/*       suppressed by choosing "outpt=0" below                     */
/*  Takashi Yamagata, 6 March 06                                    */
/********************************************************************/


proc(1)=PU_MP04(x_mat,m,case);
local outpt,n,t,al,p,y_mat,y_1_mat,z,x1,qx,ztilde,ztildet,ztildel,rhohat,yhat;
local values,vectors,zqbeta,zqbetal,resid,sigmas,sigmasq,omega;
local lambda1,matj1,omegas,omegasq,matj2,lambda,phi4;
local zq,zql,rhostar,hatrho,nt,tstara,tstarb,testvec;

/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outpt=1;/* 1: reports ourput, 0:supress the output */
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outwidth 256;

z=x_mat;
n=cols(z);
t=rows(z)-1;

    if case==1 or case==2;
    
    al = 0;    /* a1=0 implies no trend*/
    p = -1;    /* no deterministic component estimated  */ 
    
    elseif case == 3;
        al = 1;  /* linear trend*/
        p = 1;   /* trend estimated*/
    endif;    
    
              /*remove deterministic components*/
        
        if p == 0; 
            x1 = ones(t+1,1);
            qx = eye(t+1)-x1*x1'/(t+1);
        elseif p == 1;
            x1 = ones(t+1,1)~seqa(1,1,t+1);
            qx = eye(t+1)-x1*inv(x1'*x1)*x1';
        elseif p == -1;
            qx = eye(t+1);  
        endif;

        ztilde = qx*z;        
        ztildet = ztilde[2:t+1,.];
        ztildel = ztilde[1:t,.];        
        
        rhohat = tr(ztildel*ztildet')/tr(ztildel*ztildel');
        yhat = ztildet-rhohat*ztildel;       
        
        /*extract factors using normalization with smaller dimension*/
    
        if n <= t;
            {values,vectors} = eighv(yhat'*yhat);              
        else;        
            {values,vectors} = eighv(yhat*yhat');     
        endif;
        
/* number of factors should be given as "m"
*/       
            /*compute FM estimator*/

            zqbeta = ortho(ztildet,yhat,vectors,m);      /* project ztilde onto orthogonal space */
            zqbetal = ortho(ztildel,yhat,vectors,m);     
            
            resid = zqbeta-rhohat*zqbetal;
        
            /*compute variance of errors*/
        
            sigmas = sumc(abs(resid).^2)/t;
            sigmasq = sumc(sigmas)/n;
                        
            /*compute long-run covariances*/
            
            /*(bandwidth selection based on Andrews and Monahan 1992 */  
            omega=zeros(n,1);lambda1=zeros(n,1);                   
            for j (1,n,1);
                {matj1,matj2} = lrcov(resid[.,j],1,999);                
                omega[j]=matj1;
                lambda1[j]=matj2;
            endfor;            
            omegas = omega;
            omegasq = meanc(omegas);
            lambda = 0.5*(omegasq - sigmasq);
            phi4 = (omegas'*omegas)/n;            
                
            zq = zqbetal*zqbeta';        
            zql = zqbetal*zqbetal';        
            
            /* autoregressive parameter - rhostar with estimated variances */        
            
            if p == -1 or p==0; 
                rhostar = (tr(zq)-n*t*meanc(diag(lambda)))/tr(zql); 
            elseif p==1;
                rhostar = (tr(zq)+0.5*n*t*meanc(sigmas))/tr(zql);
            endif;

            /*compute test statistics*/
            
            NT = sqrt(n)*t;
            if p == -1 or p==0;
                tstara = NT*(rhostar-1)/sqrt(2*phi4/omegasq^2);
                tstarb = NT*(rhostar-1)*sqrt(tr(zql)/(n*t^2))*sqrt(omegasq/phi4);    
            elseif p == 1;
                tstara = NT*(rhostar-1)/sqrt((15/4)*phi4/omegasq^2);
                tstarb = NT*(rhostar-1)*sqrt(tr(zql)/(n*t^2))*sqrt(4*omegasq/phi4);
            endif;  
testvec=(m|tstara|tstarb);

/**/
if outpt==1;
"";
"MOON AND PERRON (2004) PANEL UNIT ROOT TEST RESULTS";
if case==1 or case==2;
"In the case without trend";
elseif case==3;
"In the case with trend";
endif;
format /rd 4,0;
"";
"N=";;n;
"Number of data points used:";;t+1;;"(T = ";;t;;")";
"Given number of factors:";;m;
"";
format /rd 10,3;
"tstar_a";;tstara;
"tstar_b";;tstarb;
"------------------------------------------------";
endif;
retp(testvec);
endp;     




/***********************************************************************/
/*************   PROCEDURES used for Moon Perron ***********************/
/***********************************************************************/

proc(1)=tr(x);
local tr;
tr=sumc(diag(x));
retp(tr);
endp;

proc(2) = LRcov(x,wght,mtd);
local t,n,xt,xl,sigma,a,v,d,i,xpw,omega,b,resid,s_resid,s4,wght1;
local s_deux,s_zero,delta,l,lambda,j,gama,w,qs,dinv;

t=rows(x);n=cols(x);
if n==1;
wght1=wght;
else;
wght1=wght|ones(n-1,1);
endif;
/*prewhitening*/

sigma = x'*x/t;

xt = x[2:t,.];
xl = x[1:t-1,.];

a = xt'*xl*inv(xl'*xl);
{d,v} = eighv(a);
for i (1,n,1);
    if (d[i,i]>0.97) or (d[i,i]<-0.97);
        d[i,i] = 0.97*(2*(d[i,i].>1)-1);
    endif;
endfor;
a = v*d*inv(v);

xpw = xt - xl*a';

omega = xpw'*xpw/t;

/*------------------*/
if mtd==999;
    /* Andrews*/
    xt = xpw[2:t-1,.];
    xl = xpw[1:t-2,.];
    b = diag((xt'*xl)./(xl'*xl));
    Resid = xt-xl*diag(b);        
    s_resid = Resid'*Resid/t;
    s4 = diag(s_resid)^2;
    
    s_deux = (4*((b)^2)*s4/((1-b)^8));
    s_zero = ( s4 ./ ((1-b).^4)); 
    delta = 1.3221*((wght1'*(s_deux))/(wght1'*(s_zero))).^(0.2);
    
endif;
/*---------------*/
L = delta*t^(0.2);

lambda = 0;
for j (1,t-2,1);
    gama = xpw[j+1:t-1,.]'*xpw[1:t-j-1,.]/t;
    v=j/L;
    w=6*pi*v/5;        
    qs=((25./(12*((pi*v).^2))).*(((sin(w))./w)-cos(w)));
    omega = omega + qs*(gama + gama');
    lambda = lambda +qs*gama;
    
endfor;

/* recolor */

dinv = inv(eye(n)-a);
omega = dinv*omega*dinv';
lambda = dinv*lambda*dinv' + sigma*a'*dinv';

retp (omega,lambda);
endp;


proc(1) = ortho(y,yhat,v,k);
local t,n,loadings,factors,betahat,norm,qbeta,x;

t=rows(y);n=cols(y);

if n <= t;
    loadings=sqrt(n)*v[.,n-k+1:n];
    factors=yhat*loadings/n;
    betahat=(yhat'*yhat)*loadings/(n*t);
else;
    factors=sqrt(t)*v[.,t-k+1:t];
    loadings=yhat'*factors/t;
    norm=loadings'*loadings/n;
    betahat=loadings*chol(norm);
endif;

qbeta=eye(n)-betahat*inv(betahat'*betahat)*betahat';

x = y*qbeta;

retp(x);
endp;

/********************************************************/
/* Gauss Procedure to estimate the number of factors    */
/* Bai and Ng (2002), DETERMINING THE NUMBER OF         */
/* FACTORS IN APPROXIMATE FACTOR MODELS, ECONOMETRICA   */
/* VOL70, 191-221.                                      */
/*                                                      */
/* {nbfactor}=bai02(xmat,kmax);                         */
/*                                                      */
/* <<INPUT>>                                            */
/* xmat: a (NxT) data matrix, where                     */
/*          N: cross section dimension                  */
/*          T: time series dimension                    */
/*                                                      */
/* kmax: maximum number of factors to set               */
/*                                                      */
/* <<OUTPUT>>                                           */
/* nbfactor: a (6 x 1) vector of estimated number of    */
/*          factors from 0,1,...,kmax                   */
/*          Each element is based on                    */
/*          Information Criteria defined in             */
/*          Bai and Ng (2002; p.201):                   */
/*          nbfactor=(PC1,PC2,PC3,IC1,IC2,IC3)'         */
/* penmat: a (maxk+1 x 6) matrix of the information     */
/*          criteria. Rows correspond to k=0,1,..., maxk*/
/*          and columns corresponds to the information  */
/*          criteron (PC1,PC2,PC3,IC1,IC2,IC3).         */
/*                                                      */
/*                                                      */
/* Takashi Yamagata                                     */
/********************************************************/

proc(2)=bai02(xmat,kmax);
local Fmatmax,Lmax,vmax,f,l;
local x,n,t,k,penmat,res,v,c_nt,p1,p2,p3;
local pc1,pc2,pc3,ic1,ic2,ic3,khat;

{Fmatmax,Lmax,vmax}=factor(xmat,kmax);
x=(xmat-meanc(xmat)')./(stdc(xmat)');
n=cols(xmat);t=rows(xmat);

k=0;
penmat={};

do while k<=kmax;


if k==0;
res=x;
else;
L=x/Fmatmax[.,1:k];
res=x-Fmatmax[.,1:k]*L;
endif;
v=meanc(diag(res'res/T));/* V(k,Fhat)*/
c_nt=minc(sqrt(N)|sqrt(T));
p1=ln(n*t/(n+t))*k*(n+t)/(n*t);
p2=ln(c_nt^2)*k*(n+t)/(n*t);
p3=ln(c_nt^2)*k/(c_nt^2);

/* IC's in Bai Ng 2002 */
pc1=v+vmax*p1;
pc2=v+vmax*p2;
pc3=v+vmax*p3;
ic1=ln(v)+p1;
ic2=ln(v)+p2;
ic3=ln(v)+p3;

penmat=penmat|(pc1~pc2~pc3~ic1~ic2~ic3);


k=k+1;
endo;

khat=minindc(penmat)-1;
retp(khat,penmat);
endp;

/* Obtain Factor and 
factor loadings given k */
proc(3)=factor(xmat,k);
local x,n,t,ei,eivec,Fmat,L,res,v;

x=(xmat-meanc(xmat)')./(stdc(xmat)');/*standardization*/
n=cols(xmat);t=rows(xmat);/*N and T*/
if n>t;
{ei,eivec}=eighv(x*x');

eivec=rev(eivec')';

Fmat=sqrt(T)*eivec[.,1:k];/*Ftilde of Bai-Ng (2002)*/
L=(Fmat'x)'/T;/*Lambda-tilde of Bai-Ng (2002)*/

else;
{ei,eivec}=eighv(x'x);

eivec=rev(eivec')';

L=sqrt(N)*eivec[.,1:k];/*Lambda-bar of Bai-Ng (2002)*/
Fmat=x*L/N;/*Fbar of Bai-Ng (2002)*/

endif;

res=x-Fmat*L';

v=meanc(diag(res'res/T));

retp(Fmat,L,v);
endp;

/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/*              PROCEDURES                  */
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**********************/
/* Pesaran's (2004) 
cross section dependenc 
test (CD test)
and Breusch-Pagan (1980)
LM test,

{cd,lm}=cdlm(y_mat);

Input: y_mat (TxN)
N: cross section dimension
T: time series dimension

output:
cd: Pesaran's (2004) CD test
lm: Breusch-Pagan (1980) LM test 

Under the null of no CSD,
cd ~ N(0,1)
lm ~ chi-squared with N(N-1)/2 dof.
*/

proc(2)=cdlm(y_mat);

local t,n,r_mat,i,j,y_mat_dm,sum_r_ij,sum_r2_ij;
local r_i,r_j,r_ij,rsq_ave,r_ave,cd,lm,nlm;
/** rank **/
t=rows(y_mat);
n=cols(y_mat);

y_mat_dm= y_mat - meanc(y_mat)';

sum_r_ij=0;
sum_r2_ij=0;

i=1;
do while i<=n-1;
    j=i+1;
        do while j<=n;
            r_i=y_mat_dm[.,i];
            r_j=y_mat_dm[.,j];
            r_ij = (r_i'r_j)/(sqrt(r_i'r_i)*sqrt(r_j'r_j));
        
        sum_r_ij=sum_r_ij + r_ij;
        sum_r2_ij=sum_r2_ij + r_ij^2;

        j=j+1;
        endo;
i=i+1;
endo;

cd=sqrt(t)*sum_r_ij/sqrt(n*(n-1)/2);
lm=(t)*sum_r2_ij;

retp(cd,lm);
endp;


/***********************************************************************************************/

/********************************************************/
/* Gauss Procedure to estimate the number of factors    */
/* Bai and Ng (2002), DETERMINING THE NUMBER OF         */
/* FACTORS IN APPROXIMATE FACTOR MODELS, ECONOMETRICA   */
/* VOL70, 191-221.                                      */
/*                                                      */
/* {nbfactor}=bai02(xmat,kmax);                         */
/*                                                      */
/* <<INPUT>>                                            */
/* xmat: a (NxT) data matrix, where                     */
/*          N: cross section dimension                  */
/*          T: time series dimension                    */
/*                                                      */
/* kmax: maximum number of factors to set               */
/*                                                      */
/* <<OUTPUT>>                                           */
/* nbfactor: a (6 x 1) vector of estimated number of    */
/*          factors from 0,1,...,kmax                   */
/*          Each element is based on                    */
/*          Information Criteria defined in             */
/*          Bai and Ng (2002; p.201):                   */
/*          nbfactor=(PC1,PC2,PC3,IC1,IC2,IC3)'         */
/* penmat: a (maxk+1 x 6) matrix of the information     */
/*          criteria. Rows correspond to k=0,1,..., maxk*/
/*          and columns corresponds to the information  */
/*          criterion (PC1,PC2,PC3,IC1,IC2,IC3).        */
/*                                                      */
/*                                                      */
/* Takashi Yamagata March 2006                          */
/********************************************************/

proc(2)=bai02(xmat,kmax);
local Fmatmax,Lmax,vmax,f,l;
local x,n,t,k,penmat,res,v,c_nt,p1,p2,p3;
local pc1,pc2,pc3,ic1,ic2,ic3,khat;

{Fmatmax,Lmax,vmax}=factor(xmat,kmax);
x=(xmat-meanc(xmat)')./(stdc(xmat)');
n=cols(xmat);t=rows(xmat);

k=0;
penmat={};

do while k<=kmax;


if k==0;
res=x;
else;
L=x/Fmatmax[.,1:k];
res=x-Fmatmax[.,1:k]*L;
endif;
v=meanc(diag(res'res/T));/* V(k,Fhat)*/
c_nt=minc(sqrt(N)|sqrt(T));
p1=ln(n*t/(n+t))*k*(n+t)/(n*t);
p2=ln(c_nt^2)*k*(n+t)/(n*t);
p3=ln(c_nt^2)*k/(c_nt^2);

/* IC's in Bai Ng 2002 */
pc1=v+vmax*p1;
pc2=v+vmax*p2;
pc3=v+vmax*p3;
ic1=ln(v)+p1;
ic2=ln(v)+p2;
ic3=ln(v)+p3;

penmat=penmat|(pc1~pc2~pc3~ic1~ic2~ic3);


k=k+1;
endo;

khat=minindc(penmat)-1;
retp(khat,penmat);
endp;

/* Obtain Factor and 
factor loadings given k */
proc(3)=factor(xmat,k);
local x,n,t,ei,eivec,Fmat,L,res,v;

x=(xmat-meanc(xmat)')./(stdc(xmat)');/*standardization*/
n=cols(xmat);t=rows(xmat);/*N and T*/
if n>t;
{ei,eivec}=eighv(x*x');

eivec=rev(eivec')';

Fmat=sqrt(T)*eivec[.,1:k];/*Ftilde of Bai-Ng (2002)*/
L=(Fmat'x)'/T;/*Lambda-tilde of Bai-Ng (2002)*/

else;
{ei,eivec}=eighv(x'x);

eivec=rev(eivec')';

L=sqrt(N)*eivec[.,1:k];/*Lambda-bar of Bai-Ng (2002)*/
Fmat=x*L/N;/*Fbar of Bai-Ng (2002)*/

endif;

res=x-Fmat*L';

v=meanc(diag(res'res/T));

retp(Fmat,L,v);
endp;

/***********************************************************************************************/

/*************************************************************************/
/* THIS VERSION: 13/03/06                                               **/
/* COMPUTE CIPS(P) AND CIPS*(P) STATISTICS IN M.H.PESARAN               **/
/* " A SIMPLE PANEL UNIT ROOT TEST UNDER CROSS SECTION DEPENDENCE"      **/
/*  FEBRUARY 2006                                                       **/
/* NOTE:                                                                **/
/* Please report any problems you might have, to: ty228@cam.ac.uk       **/
/*                                                                      **/
/* {CIPSmat,cadf_p_mat,cadfs_p_mat,res_p_mat}=cips(var_mat,maxp,case)   **/
/* <<INPUTS>>                                                           **/
/* var_mat (T x N) matrix                                               **/
/* N            : number of cross section dimension                     **/
/* T		: number of observations for i's                            **/
/* maxp (more than or equal to zero) : maximum number of (ADF) lag order**/
/*                                    eg. maxp=0: CADF==CDF             **/
/* case=1: no intercept nor trend                                       **/
/* case=2: with intercept                                               **/
/* case=3: with intercept and trend                                     **/
/* <<OUTPUTS>>                                                          **/
/* CIPSmat: (maxp+1) x 2 matrix, first column reports                   **/
/*          CIPS(p) and second column reports CIPS*(p)                  **/
/*          for p=0,1,...,maxp in ascending order                       **/
/*     -CIPS(p) statistic is defined as simple average of               **/
/*       CADF(p)_i statistics                                           **/
/*     -CIPS*(p) statistic is defined as simple average of              **/
/*       CADF*(p)_i statistics, which is truncated version of CADF_i.   **/   
/*                                                                      **/   
/* cadf_p_mat: a N x (maxp+1) matrix, reports all CADF(p)_i statistics  **/   
/* cadfs_p_mat: a N x (maxp+1) matrix, reports all CADF*(p)_i statistics**/
/* res_p_mat: a (maxp+1) set of						                    **/ 
/*		T-(maxp+1) x N matrix of residuals of CADF(p)_i regressions	    **/
/*              concatenated vertically, from the top p=0,p=1,,,p=maxp  **/    
/*                                                                      **/   
/* NB: Appropriate critical values for CIPS statistic are found         **/
/*  are in Table 2 in Pesaran (2006)                                    **/    
/*                                                                      **/
/* NOTEs: Default setting is to print the results. It can be            **/
/*       suppressed by choosing "outpt=0" below (7th-line of the code   **/
/* Takashi Yamagata, 13 March2006                                       **/
/*                                                                      **/
/*************************************************************************/
proc(4)=cips(var_mat,maxp,case);
local outpt,n,t,tlag,var_mat_1,Dvar_mat_temp,Dvar_mat,Dvar_CSM,var_1_CSM;
local tt,y,z,hi,x,h,k1,k2,bvec,sevec,t_vec_cce,t_bar,i,c_p,temp;
local trncl,truncu,trnc1,cadf_p,cadf_ps,cips_p_mat,cips_p,cips_ps;
local cadf_p_mat,cadfs_p_mat,idvec,lgorder,res_p_mat,res_p;


/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outpt=1;/* 1: reports ourput, 0:supress the output */
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outwidth 256;

t=rows(var_mat);
n=cols(var_mat);
tlag=maxp+1;

var_mat_1=lag(var_mat);
Dvar_mat_temp=var_mat-var_mat_1;
    var_mat_1=var_mat_1[tlag+1:t,.];
    Dvar_mat=Dvar_mat_temp[tlag+1:t,.];

Dvar_CSM=meanc(Dvar_mat');
var_1_CSM=meanc(var_mat_1');

tt=t-tlag;

/*************/
y=vec(Dvar_mat);
Hi=Dvar_CSM~var_1_CSM;
x=vec(var_mat_1);

/****/
if case==1;k1=-6.12;k2=4.16;
elseif case==2;Z=ones(n*tt,1);k1=-6.19;k2=2.61;
elseif case==3;Z=ones(n*tt,1)~(ONES(N,1).*.seqa(1,1,tt));k1=-6.42;k2=1.70;
else;"please choose the 'case' only from 1,2, or 3";end;
endif;

/**************** ESTIMATION ****************/
c_p=0;
cips_p_mat={};
cadf_p_mat={};
cadfs_p_mat={};
res_p_mat={};
do while c_p<=maxp;

if c_p>0;
    temp=(Dvar_mat_temp[tlag+1-c_p:t-c_p,.]);
    Hi=Hi~meanc(temp'); 
    x=x~vec(temp);
endif;

/*************/
if case==1;H=(ONES(N,1).*.Hi);
else;H=Z~(ONES(N,1).*.Hi);
endif;

/*** MGCCE ****/
{bvec,sevec,t_vec_cce,res_p}=mgsimple(y,x~h,n,tt);

trncl=k1*(t_vec_cce[.,1].<k1);truncu=k2*(t_vec_cce[.,1].>k2);
trnc1=(t_vec_cce[.,1].>k1).*(t_vec_cce[.,1].<k2);

cadf_p = t_vec_cce[.,1];
cadf_ps = (t_vec_cce[.,1].*trnc1+trncl+truncu);

cips_p=meanc(cadf_p);
cips_ps=meanc(cadf_ps);

if outpt==1;
format /rd 2,0;
"@@@@@@@@@@@@@@@@@@@ CADF(";;C_P;;") @@@@@@@@@@@@@@@@@@@@";
format /rd 2,0;
"CIPS TEST: CASE";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 5,0;
"N=";;n;;", T=";;tt;;", (";;t;;"data points used)";
format /rd 8,3;
"   CIPS            :";;cips_p;
"   CIPS*(truncated):";;cips_ps;
"* Truncation is done for CADF_i in such a way that" ;
format /rd 1,2;
"when CADF_i<k1, CADF_i=k1 and when CADF_i>k2, CADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
"Appropriate critical values are in Table 2, Pesaran (2006).";
"-------------------------------------------------------";
"";
endif;
cips_p_mat=cips_p_mat|(cips_p~cips_ps);
cadf_p_mat=cadf_p_mat~cadf_p;
cadfs_p_mat=cadfs_p_mat~cadf_ps;

res_p_mat=res_p_mat|res_p;

    c_p=c_p+1;
endo;

if outpt==1;
format /rd 8,0;
idvec=ftocv(seqa(1,1,n),1,0);
lgorder="id/p"~ftocv(seqa(0,1,maxp+1)',1,0);

format /rd 2,0;
"";
"*****************************************************";
"CADF_i(p) Statistics: Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(cadf_p_mat,1,3)));
"";
"Appropriate critical values are in Table 1, Pesaran (2006).";
"*****************************************************";
format /rd 2,0;
"CADF*_i(p) Statistics (truncated): Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT and TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(cadfs_p_mat,1,3)));
"* Truncation is done for CADF_i in such a way that" ;
format /rd 1,2;
"when CADF_i<k1, CADF_i=k1 and when CADF_i>k2, CADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
"Appropriate critical values are in Table 1, Pesaran (2006).";
endif;

format /rd 16,8;
retp(cips_p_mat,cadf_p_mat,cadfs_p_mat,res_p_mat);
endp;

/*** OLS regression for each cross section unit ****/
proc(4)=mgsimple(y,x,n,t);
local bvec,sevec,tvec,i,y_i,x_i,beta_i,e_i,zig2,se_i,t_i,res_mat;
bvec=zeros(n,cols(x));
sevec=zeros(n,cols(x));
tvec=zeros(n,cols(x));
res_mat={};
i=1;
do while i<=n;
    y_i=y[1+(i-1)*t:(i)*t,.];
    x_i=x[1+(i-1)*t:(i)*t,.];
    beta_i=y_i/x_i;
    e_i=y_i-x_i*beta_i;
    zig2=e_i'e_i/(T-cols(x));
    se_i=sqrt(diag(zig2*invpd(x_i'x_i)));
    t_i=beta_i./se_i;

    bvec[i,.]=beta_i';
    sevec[i,.]=se_i';
    tvec[i,.]=t_i';
    res_mat=res_mat~e_i;

i=i+1;
endo;

retp(bvec,sevec,tvec,res_mat);
endp;

/***********************************************************************************************/

/**  cp and cz test of cadf test	*/
/**  in Pesaran (2007)                 **/
/*
     Critical values are shown in 
     Excel file "CVTable_CZ_CP.xls"	*/
/** {cp_cadf,cz_cadf}=cp(cadf,case);   **/
/*
    <<INPUT>>
    cadf: N x 1 vector of cadf_i statistics with caseI, II or III of:
        case=1:without deterministics
        case=2:with an intercept only
        case=3:with an intercept and a linear trend
    <<OUTPUT>>
    cp_cadf: cp test statistic in Pesaran (2007)
    cz_cadf: cz test statistic in Pesaran (2007)

Please do choose correct quantiles, associated with
the cases (CASEI, II, III) 
*/

proc(2)=cz_cp(cadf,case);

local N,quant,quant1,quant2,quant3,pvec,i,qtemp,cadf_i,p_i,cp_cadf,cz_cadf;
N=rows(cadf);

quant1=
{
0.0001	-4.002785865
0.0012	-3.793484224
0.0022	-3.650056068
0.0032	-3.558509861
0.0042	-3.477353638
0.0052	-3.409558313
0.0062	-3.361626802
0.0072	-3.318025747
0.0082	-3.275673191
0.0092	-3.233701852
0.0102	-3.199445334
0.0112	-3.175827233
0.0123	-3.148407197
0.0133	-3.122458087
0.0143	-3.099960573
0.0153	-3.081187694
0.0163	-3.058673198
0.0173	-3.040647573
0.0183	-3.021596248
0.0193	-3.00304701
0.0203	-2.98204105
0.0213	-2.962822234
0.0223	-2.944659509
0.0234	-2.926827745
0.0244	-2.907373921
0.0254	-2.892443251
0.0264	-2.877274254
0.0274	-2.862110488
0.0284	-2.847298429
0.0294	-2.827009121
0.0304	-2.811752741
0.0314	-2.799771369
0.0324	-2.78746573
0.0334	-2.77210061
0.0345	-2.759900134
0.0355	-2.747429513
0.0365	-2.738277499
0.0375	-2.725627052
0.0385	-2.716156207
0.0395	-2.707558069
0.0405	-2.697264355
0.0415	-2.68643491
0.0425	-2.676463026
0.0435	-2.666281276
0.0446	-2.654718156
0.0456	-2.644449833
0.0466	-2.63646095
0.0476	-2.624337584
0.0486	-2.615484591
0.0496	-2.606311354
0.0506	-2.596264018
0.0516	-2.585279339
0.0526	-2.575204626
0.0536	-2.566702059
0.0546	-2.557323816
0.0556	-2.548830523
0.0567	-2.540394771
0.0577	-2.534382431
0.0587	-2.524705344
0.0597	-2.514435555
0.0607	-2.507257769
0.0617	-2.500821574
0.0627	-2.491321673
0.0637	-2.484034107
0.0647	-2.477571912
0.0657	-2.470360333
0.0667	-2.462747893
0.0678	-2.455349315
0.0688	-2.449314774
0.0698	-2.44291894
0.0708	-2.435625272
0.0718	-2.429249541
0.0728	-2.421064548
0.0738	-2.415913481
0.0748	-2.408672861
0.0758	-2.401072246
0.0768	-2.394693807
0.0779	-2.387989681
0.0789	-2.382357289
0.0799	-2.376089182
0.0809	-2.369956592
0.0819	-2.363578235
0.0829	-2.357423969
0.0839	-2.351644067
0.0849	-2.346608465
0.0859	-2.340051558
0.0869	-2.334589122
0.0879	-2.328601041
0.089	-2.321676198
0.09	-2.315740815
0.091	-2.30968654
0.092	-2.304280545
0.093	-2.299208108
0.094	-2.293437771
0.095	-2.286930683
0.096	-2.281009712
0.097	-2.275028468
0.098	-2.271000773
0.099	-2.265100126
0.1	-2.264288794
0.1002	-2.223284199
0.1082	-2.186105173
0.1163	-2.153731456
0.1244	-2.120184031
0.1325	-2.084809385
0.1405	-2.050438878
0.1486	-2.01769749
0.1567	-1.986867431
0.1648	-1.957784519
0.1729	-1.930904132
0.1809	-1.905641818
0.189	-1.875879373
0.1971	-1.849753046
0.2052	-1.822085408
0.2133	-1.795242773
0.2213	-1.766995421
0.2294	-1.741166104
0.2375	-1.717533717
0.2456	-1.693742828
0.2536	-1.669266939
0.2617	-1.646075477
0.2698	-1.623332585
0.2779	-1.600167636
0.286	-1.579146847
0.294	-1.556601643
0.3021	-1.534875126
0.3102	-1.513050067
0.3183	-1.491591454
0.3264	-1.471363904
0.3344	-1.45019031
0.3425	-1.426738675
0.3506	-1.405817258
0.3587	-1.385701547
0.3668	-1.365634297
0.3748	-1.345736913
0.3829	-1.324641132
0.391	-1.303353774
0.3991	-1.283628734
0.4071	-1.262578396
0.4152	-1.241900756
0.4233	-1.218968846
0.4314	-1.199308045
0.4395	-1.177932986
0.4475	-1.158178266
0.4556	-1.139406016
0.4637	-1.119628795
0.4718	-1.100377082
0.4799	-1.080999343
0.4879	-1.060622381
0.496	-1.038652243
0.5041	-1.018824872
0.5122	-0.997877391
0.5202	-0.97592309
0.5283	-0.955857904
0.5364	-0.934754968
0.5445	-0.911864249
0.5526	-0.890542326
0.5606	-0.869578964
0.5687	-0.846314467
0.5768	-0.823189355
0.5849	-0.799923103
0.593	-0.77798813
0.601	-0.753038066
0.6091	-0.729360926
0.6172	-0.709002758
0.6253	-0.687683338
0.6334	-0.663368696
0.6414	-0.638801518
0.6495	-0.612546674
0.6576	-0.588117363
0.6657	-0.563780864
0.6737	-0.538378045
0.6818	-0.514578088
0.6899	-0.488165234
0.698	-0.459770255
0.7061	-0.432103901
0.7141	-0.405298
0.7222	-0.377290338
0.7303	-0.349212303
0.7384	-0.317678255
0.7465	-0.289122589
0.7545	-0.258167271
0.7626	-0.225091554
0.7707	-0.192706877
0.7788	-0.160923576
0.7868	-0.126295033
0.7949	-0.095200644
0.803	-0.060038889
0.8111	-0.021256725
0.8192	0.016299967
0.8272	0.054141781
0.8353	0.091873428
0.8434	0.1355745
0.8515	0.181736809
0.8596	0.226113205
0.8676	0.273705811
0.8757	0.318845392
0.8838	0.371179581
0.8919	0.423229431
0.8999	0.424563175
0.9	0.430971056
0.9011	0.437430866
0.9021	0.445185609
0.9031	0.452155556
0.9041	0.459513589
0.9051	0.46753644
0.9061	0.475130667
0.9071	0.482350811
0.9081	0.490442477
0.9091	0.497740641
0.9102	0.503855988
0.9112	0.513030098
0.9122	0.522499306
0.9132	0.529309933
0.9142	0.53689871
0.9152	0.54301729
0.9162	0.552159687
0.9172	0.56099093
0.9182	0.570516364
0.9192	0.578992987
0.9203	0.587438869
0.9213	0.59613821
0.9223	0.604647091
0.9233	0.612617452
0.9243	0.621775671
0.9253	0.627976529
0.9263	0.638787227
0.9273	0.64884499
0.9283	0.657212645
0.9293	0.665897
0.9304	0.675451241
0.9314	0.685315824
0.9324	0.693696423
0.9334	0.702620594
0.9344	0.711356353
0.9354	0.718166677
0.9364	0.728114673
0.9374	0.735834565
0.9384	0.745438107
0.9394	0.756206725
0.9405	0.767253141
0.9415	0.775648594
0.9425	0.785418234
0.9435	0.794877566
0.9445	0.805742593
0.9455	0.817294061
0.9465	0.828581046
0.9475	0.842088943
0.9485	0.854930527
0.9495	0.86668997
0.9506	0.880387277
0.9516	0.891242455
0.9526	0.907741432
0.9536	0.921684463
0.9546	0.931863808
0.9556	0.948586239
0.9566	0.960018667
0.9576	0.971684876
0.9586	0.982331803
0.9596	0.997878152
0.9607	1.010043344
0.9617	1.022250289
0.9627	1.038165193
0.9637	1.050441276
0.9647	1.065413007
0.9657	1.085323109
0.9667	1.102452255
0.9677	1.120074875
0.9687	1.139725416
0.9697	1.156126785
0.9708	1.173524366
0.9718	1.190200109
0.9728	1.209576237
0.9738	1.230566179
0.9748	1.25026623
0.9758	1.278414697
0.9768	1.303899903
0.9778	1.326116889
0.9788	1.348280189
0.9798	1.372311795
0.9809	1.394278192
0.9819	1.420191777
0.9829	1.450048231
0.9839	1.48375548
0.9849	1.520427179
0.9859	1.555609953
0.9869	1.589786777
0.9879	1.640677766
0.9889	1.676855527
0.9899	1.719552082
0.991	1.763198457
0.992	1.817832364
0.993	1.894676811
0.994	1.976371133
0.995	2.056868215
0.996	2.173053072
0.997	2.311083185
0.998	2.496357602
0.999	3.451902419
};
quant1=reshape(quant1,299,2);

quant2=
{
0.0001	-4.504922023
0.0012	-4.355987236
0.0022	-4.231212264
0.0032	-4.131181641
0.0042	-4.066080018
0.0052	-4.003504207
0.0062	-3.959352924
0.0072	-3.911575727
0.0082	-3.870338699
0.0092	-3.831558913
0.0102	-3.79840273
0.0112	-3.773815874
0.0123	-3.742260296
0.0133	-3.718284892
0.0143	-3.697214286
0.0153	-3.672346983
0.0163	-3.651733135
0.0173	-3.630299063
0.0183	-3.608253048
0.0193	-3.587319088
0.0203	-3.567734505
0.0213	-3.550874054
0.0223	-3.536465561
0.0234	-3.520693284
0.0244	-3.502779273
0.0254	-3.488651647
0.0264	-3.473304182
0.0274	-3.45686126
0.0284	-3.44484082
0.0294	-3.433531874
0.0304	-3.421178977
0.0314	-3.407919525
0.0324	-3.395362163
0.0334	-3.383932271
0.0345	-3.372713376
0.0355	-3.361802942
0.0365	-3.351737537
0.0375	-3.343256852
0.0385	-3.332983877
0.0395	-3.322426372
0.0405	-3.312558775
0.0415	-3.304264509
0.0425	-3.294796514
0.0435	-3.284763636
0.0446	-3.275690802
0.0456	-3.265699955
0.0466	-3.257421788
0.0476	-3.249899775
0.0486	-3.242093702
0.0496	-3.233490229
0.0506	-3.227605119
0.0516	-3.218168742
0.0526	-3.210609122
0.0536	-3.200789215
0.0546	-3.194119182
0.0556	-3.185205168
0.0567	-3.176646418
0.0577	-3.168348098
0.0587	-3.161123996
0.0597	-3.154041951
0.0607	-3.148331589
0.0617	-3.14089911
0.0627	-3.134782218
0.0637	-3.128190091
0.0647	-3.119602935
0.0657	-3.113595789
0.0667	-3.106923238
0.0678	-3.100992103
0.0688	-3.0950429
0.0698	-3.088858759
0.0708	-3.082003243
0.0718	-3.07452432
0.0728	-3.06784166
0.0738	-3.06277914
0.0748	-3.055400484
0.0758	-3.048288236
0.0768	-3.041788042
0.0779	-3.036544671
0.0789	-3.030460328
0.0799	-3.022698852
0.0809	-3.018107526
0.0819	-3.012015794
0.0829	-3.005598362
0.0839	-2.999084728
0.0849	-2.993362204
0.0859	-2.987311736
0.0869	-2.982482755
0.0879	-2.975801075
0.089	-2.970804971
0.09	-2.964785663
0.091	-2.959199148
0.092	-2.954784823
0.093	-2.949844
0.094	-2.94465973
0.095	-2.939089749
0.096	-2.934615608
0.097	-2.929071757
0.098	-2.923775039
0.099	-2.918581056
0.1	-2.918284995
0.1002	-2.880221834
0.1082	-2.841463259
0.1163	-2.808957198
0.1244	-2.775725036
0.1325	-2.747672392
0.1405	-2.717452401
0.1486	-2.689178816
0.1567	-2.662039242
0.1648	-2.634076283
0.1729	-2.605761732
0.1809	-2.581490301
0.189	-2.557535049
0.1971	-2.533073952
0.2052	-2.508472395
0.2133	-2.484652865
0.2213	-2.461785717
0.2294	-2.43952223
0.2375	-2.416895112
0.2456	-2.39601894
0.2536	-2.374821598
0.2617	-2.354291289
0.2698	-2.332748704
0.2779	-2.310974531
0.286	-2.290477064
0.294	-2.268951908
0.3021	-2.25158177
0.3102	-2.232439334
0.3183	-2.214708579
0.3264	-2.197000634
0.3344	-2.176473353
0.3425	-2.158005944
0.3506	-2.139637771
0.3587	-2.122183224
0.3668	-2.102575688
0.3748	-2.083997161
0.3829	-2.065946738
0.391	-2.046567118
0.3991	-2.029593617
0.4071	-2.010848708
0.4152	-1.993334329
0.4233	-1.975456661
0.4314	-1.957541892
0.4395	-1.940736965
0.4475	-1.923692306
0.4556	-1.904637059
0.4637	-1.886587709
0.4718	-1.868627812
0.4799	-1.849855628
0.4879	-1.831472533
0.496	-1.814275932
0.5041	-1.796599344
0.5122	-1.778801803
0.5202	-1.760938558
0.5283	-1.743265286
0.5364	-1.725483561
0.5445	-1.707645993
0.5526	-1.691143263
0.5606	-1.672327841
0.5687	-1.654319344
0.5768	-1.636036911
0.5849	-1.61805812
0.593	-1.599411007
0.601	-1.580755033
0.6091	-1.562570043
0.6172	-1.544333102
0.6253	-1.523811475
0.6334	-1.503886726
0.6414	-1.48438614
0.6495	-1.464706931
0.6576	-1.446021652
0.6657	-1.427212711
0.6737	-1.406105066
0.6818	-1.386138149
0.6899	-1.366107379
0.698	-1.346141773
0.7061	-1.32291593
0.7141	-1.302254403
0.7222	-1.281174989
0.7303	-1.258552144
0.7384	-1.233272554
0.7465	-1.208996074
0.7545	-1.185436607
0.7626	-1.159315271
0.7707	-1.134110938
0.7788	-1.108084136
0.7868	-1.082282722
0.7949	-1.053932321
0.803	-1.027181938
0.8111	-0.999907864
0.8192	-0.968506807
0.8272	-0.936818295
0.8353	-0.905327855
0.8434	-0.869859216
0.8515	-0.830944678
0.8596	-0.794267341
0.8676	-0.757239195
0.8757	-0.717930689
0.8838	-0.677162198
0.8919	-0.632757179
0.8999	-0.631344608
0.9	-0.626426043
0.9011	-0.620609914
0.9021	-0.61610404
0.9031	-0.611330924
0.9041	-0.604915442
0.9051	-0.598756657
0.9061	-0.592359791
0.9071	-0.587815219
0.9081	-0.582032159
0.9091	-0.57577848
0.9102	-0.570421368
0.9112	-0.56335456
0.9122	-0.557695659
0.9132	-0.550853161
0.9142	-0.545137896
0.9152	-0.53933988
0.9162	-0.533244783
0.9172	-0.52562244
0.9182	-0.518470173
0.9192	-0.511993056
0.9203	-0.505413839
0.9213	-0.499462764
0.9223	-0.493397741
0.9233	-0.485524642
0.9243	-0.477806717
0.9253	-0.472028321
0.9263	-0.465304245
0.9273	-0.457665817
0.9283	-0.451879454
0.9293	-0.443709776
0.9304	-0.435529817
0.9314	-0.425769314
0.9324	-0.416297636
0.9334	-0.409160221
0.9344	-0.39915293
0.9354	-0.390112772
0.9364	-0.381466836
0.9374	-0.374841313
0.9384	-0.364502842
0.9394	-0.355709678
0.9405	-0.346944842
0.9415	-0.336650671
0.9425	-0.325576433
0.9435	-0.314611998
0.9445	-0.304963711
0.9455	-0.293761399
0.9465	-0.284446119
0.9475	-0.27413857
0.9485	-0.263077419
0.9495	-0.254804737
0.9506	-0.245404338
0.9516	-0.231955652
0.9526	-0.221536931
0.9536	-0.212906195
0.9546	-0.202533176
0.9556	-0.19001729
0.9566	-0.179146524
0.9576	-0.167967457
0.9586	-0.154390409
0.9596	-0.14299273
0.9607	-0.129509248
0.9617	-0.120569609
0.9627	-0.108155455
0.9637	-0.094313185
0.9647	-0.082227154
0.9657	-0.065309611
0.9667	-0.051814954
0.9677	-0.039503442
0.9687	-0.023140785
0.9697	-0.008161986
0.9708	0.005113494
0.9718	0.023034356
0.9728	0.041829214
0.9738	0.05799397
0.9748	0.072149166
0.9758	0.087295242
0.9768	0.112894534
0.9778	0.131147338
0.9788	0.152810557
0.9798	0.178431351
0.9809	0.199117609
0.9819	0.226263111
0.9829	0.249115611
0.9839	0.274533534
0.9849	0.310116227
0.9859	0.342358542
0.9869	0.3732947
0.9879	0.407838024
0.9889	0.441398661
0.9899	0.483714402
0.991	0.526068254
0.992	0.585644379
0.993	0.654306256
0.994	0.706744134
0.995	0.783936326
0.996	0.873881338
0.997	1.015435329
0.998	1.255984819
0.999	2.054578227
};
quant2=reshape(quant2,299,2);

quant3=
{
0.0001	-5.028406462
0.0012	-4.794663974
0.0022	-4.669102781
0.0032	-4.588843644
0.0042	-4.535155887
0.0052	-4.471642706
0.0062	-4.415800073
0.0072	-4.372570938
0.0082	-4.33817315
0.0092	-4.302098098
0.0102	-4.265964091
0.0112	-4.234153174
0.0123	-4.207202829
0.0133	-4.182423531
0.0143	-4.152688904
0.0153	-4.131006609
0.0163	-4.112695264
0.0173	-4.095331512
0.0183	-4.078071553
0.0193	-4.057837232
0.0203	-4.044929976
0.0213	-4.026250279
0.0223	-4.010983436
0.0234	-3.996722265
0.0244	-3.978371897
0.0254	-3.967116299
0.0264	-3.954831625
0.0274	-3.940741336
0.0284	-3.927326129
0.0294	-3.917333942
0.0304	-3.906511896
0.0314	-3.894924822
0.0324	-3.884267444
0.0334	-3.872941272
0.0345	-3.86247245
0.0355	-3.85111116
0.0365	-3.842103903
0.0375	-3.830361597
0.0385	-3.819511776
0.0395	-3.809073847
0.0405	-3.799142684
0.0415	-3.788670807
0.0425	-3.779220917
0.0435	-3.768126105
0.0446	-3.759598337
0.0456	-3.751590233
0.0466	-3.742103301
0.0476	-3.733569337
0.0486	-3.724812613
0.0496	-3.713816641
0.0506	-3.706820789
0.0516	-3.699742734
0.0526	-3.689733539
0.0536	-3.682327393
0.0546	-3.675523448
0.0556	-3.666356145
0.0567	-3.658334094
0.0577	-3.65046476
0.0587	-3.641894193
0.0597	-3.634822949
0.0607	-3.628593947
0.0617	-3.622405364
0.0627	-3.614748767
0.0637	-3.607759411
0.0647	-3.601505137
0.0657	-3.596018236
0.0667	-3.588978444
0.0678	-3.583907714
0.0688	-3.577568215
0.0698	-3.570603822
0.0708	-3.56217184
0.0718	-3.55500864
0.0728	-3.548326866
0.0738	-3.542087215
0.0748	-3.533189386
0.0758	-3.526199512
0.0768	-3.521040382
0.0779	-3.514013201
0.0789	-3.506814782
0.0799	-3.501244782
0.0809	-3.496582983
0.0819	-3.491171281
0.0829	-3.486010113
0.0839	-3.480871671
0.0849	-3.475813676
0.0859	-3.47023519
0.0869	-3.464597218
0.0879	-3.459004761
0.089	-3.454292319
0.09	-3.448121438
0.091	-3.443742465
0.092	-3.438562633
0.093	-3.433016589
0.094	-3.427410462
0.095	-3.423276084
0.096	-3.417325925
0.097	-3.412142003
0.098	-3.407376028
0.099	-3.403646492
0.1	-3.403323096
0.1002	-3.362748601
0.1082	-3.328807687
0.1163	-3.299392114
0.1244	-3.26769436
0.1325	-3.238705813
0.1405	-3.210781885
0.1486	-3.183827776
0.1567	-3.158890805
0.1648	-3.130363008
0.1729	-3.104758157
0.1809	-3.077548663
0.189	-3.051972422
0.1971	-3.027741212
0.2052	-3.005109315
0.2133	-2.983109389
0.2213	-2.960968912
0.2294	-2.939137558
0.2375	-2.917120863
0.2456	-2.897003042
0.2536	-2.877466209
0.2617	-2.857039184
0.2698	-2.838425165
0.2779	-2.820211625
0.286	-2.801732101
0.294	-2.783246777
0.3021	-2.765281135
0.3102	-2.74638847
0.3183	-2.728385177
0.3264	-2.710407932
0.3344	-2.692521969
0.3425	-2.67617046
0.3506	-2.658951811
0.3587	-2.641492111
0.3668	-2.624912382
0.3748	-2.60561675
0.3829	-2.589661233
0.391	-2.573135019
0.3991	-2.555743551
0.4071	-2.539595974
0.4152	-2.523263651
0.4233	-2.507115047
0.4314	-2.49089051
0.4395	-2.473877149
0.4475	-2.456349904
0.4556	-2.440034447
0.4637	-2.424950229
0.4718	-2.408511883
0.4799	-2.391815948
0.4879	-2.374966474
0.496	-2.35926204
0.5041	-2.342812464
0.5122	-2.32692638
0.5202	-2.31146686
0.5283	-2.294852186
0.5364	-2.279832439
0.5445	-2.264179603
0.5526	-2.248311684
0.5606	-2.232186246
0.5687	-2.215737026
0.5768	-2.19954152
0.5849	-2.183210159
0.593	-2.167967662
0.601	-2.151370145
0.6091	-2.134361994
0.6172	-2.118347346
0.6253	-2.101557351
0.6334	-2.084163261
0.6414	-2.065715886
0.6495	-2.048437756
0.6576	-2.028861925
0.6657	-2.009950562
0.6737	-1.992616501
0.6818	-1.973915554
0.6899	-1.955767782
0.698	-1.936313916
0.7061	-1.915792204
0.7141	-1.896860129
0.7222	-1.878191195
0.7303	-1.858294226
0.7384	-1.835746126
0.7465	-1.814231412
0.7545	-1.793331502
0.7626	-1.770751789
0.7707	-1.748074735
0.7788	-1.725765298
0.7868	-1.702849382
0.7949	-1.678523747
0.803	-1.656545236
0.8111	-1.631129275
0.8192	-1.605178526
0.8272	-1.578986284
0.8353	-1.553750394
0.8434	-1.52657187
0.8515	-1.498247932
0.8596	-1.466679572
0.8676	-1.431887099
0.8757	-1.393890917
0.8838	-1.357572503
0.8919	-1.318498382
0.8999	-1.316728087
0.9	-1.311588602
0.9011	-1.305471162
0.9021	-1.300891085
0.9031	-1.294343513
0.9041	-1.288761296
0.9051	-1.283153719
0.9061	-1.27704336
0.9071	-1.272032121
0.9081	-1.267400575
0.9091	-1.262796374
0.9102	-1.257525231
0.9112	-1.250818254
0.9122	-1.24634966
0.9132	-1.24144928
0.9142	-1.2360935
0.9152	-1.230556117
0.9162	-1.22447914
0.9172	-1.218755281
0.9182	-1.212670526
0.9192	-1.205297377
0.9203	-1.198739879
0.9213	-1.19215051
0.9223	-1.183629333
0.9233	-1.178215331
0.9243	-1.172503416
0.9253	-1.168006851
0.9263	-1.162149119
0.9273	-1.154518401
0.9283	-1.147094357
0.9293	-1.139807847
0.9304	-1.130455091
0.9314	-1.123591874
0.9324	-1.116905252
0.9334	-1.109388474
0.9344	-1.101757915
0.9354	-1.092887581
0.9364	-1.08594196
0.9374	-1.080126064
0.9384	-1.070612013
0.9394	-1.060970285
0.9405	-1.05191041
0.9415	-1.044026564
0.9425	-1.036411356
0.9435	-1.028931332
0.9445	-1.021198526
0.9455	-1.013396194
0.9465	-1.003841626
0.9475	-0.994580144
0.9485	-0.985026931
0.9495	-0.975463668
0.9506	-0.968059711
0.9516	-0.957971406
0.9526	-0.949643731
0.9536	-0.941077742
0.9546	-0.932093016
0.9556	-0.922362775
0.9566	-0.913124726
0.9576	-0.904655849
0.9586	-0.894008992
0.9596	-0.884215282
0.9607	-0.875486846
0.9617	-0.864587537
0.9627	-0.85595986
0.9637	-0.84543826
0.9647	-0.83565164
0.9657	-0.823918012
0.9667	-0.809639303
0.9677	-0.796770132
0.9687	-0.78266287
0.9697	-0.768479031
0.9708	-0.750428901
0.9718	-0.734854772
0.9728	-0.719090383
0.9738	-0.698002046
0.9748	-0.676415016
0.9758	-0.658904946
0.9768	-0.638952052
0.9778	-0.621251526
0.9788	-0.601225377
0.9798	-0.576507669
0.9809	-0.55398708
0.9819	-0.534862075
0.9829	-0.51099627
0.9839	-0.47902372
0.9849	-0.4572896
0.9859	-0.433381904
0.9869	-0.398693089
0.9879	-0.362401964
0.9889	-0.333288173
0.9899	-0.292024316
0.991	-0.26062032
0.992	-0.220812572
0.993	-0.183731752
0.994	-0.147783082
0.995	-0.072195902
0.996	0.019238582
0.997	0.151966993
0.998	0.334973155
0.999	0.927266369
};
quant3=reshape(quant3,299,2);

if case==1;quant=quant1;
elseif case==2;quant=quant2;
elseif case==3;quant=quant3;
endif;

pvec={};
i=1;

do while i<=N;
    qtemp=quant;
    cadf_i=cadf[i];
        if      cadf_i<qtemp[1,2];p_i=0.000001;
        elseif  cadf_i>qtemp[rows(qtemp),2];p_i=0.999999;
        else;qtemp=delif(qtemp,qtemp[.,2].>cadf_i);
             p_i=qtemp[rows(qtemp),1];
        endif;
    pvec=pvec|(p_i);
    i=i+1;
endo;

cp_cadf=-2*sumc(ln(pvec));
cz_cadf=sumc(cdfni(pvec))/sqrt(n);

retp(cp_cadf,cz_cadf);
endp;


/***********************************************************************************************/

/*************************************************************************/
/* THIS VERSION: 13/03/06                                               **/
/* COMPUTE tbar(P) (AND tbar*(P)) STATISTICS IN IM, PESARAN, SHIN (2003)**/
/* "Testing for unit roots in heterogeneous panels", Journal of         **/
/*  Econometrics 115, 53-74.                                            **/
/* For the truncated version, see Pesaran (2006),                       **/
/* " A SIMPLE PANEL UNIT ROOT TEST UNDER CROSS SECTION DEPENDENCE"      **/
/*  FEBRUARY 2006                                                       **/
/* NOTE:                                                                **/
/* Please report any problems you might have, to: ty228@econ.cam.ac.uk  **/
/*                                                                      **/
/* {tbarmat,adf_p_mat,adfs_p_mat,res_p_mat}=ips(var_mat,maxp,case);     **/
/*                                                                      **/
/* <<INPUTS>>                                                           **/
/* var_mat (T x N) matrix                                               **/
/* N            : number of cross section dimension                     **/
/* T		: number of observations for i's                            **/
/* maxp (more than or equal to zero) : maximum number of (ADF) lag order**/
/*                                    eg. maxp=0: ADF==DF               **/
/* case=1: no intercept nor trend                                       **/
/* case=2: with intercept                                               **/
/* case=3: with intercept and trend                                     **/
/* <<OUTPUTS>>                                                          **/
/* tbarmat: (maxp+1) x 2 matrix, first column reports                   **/
/*          tbar(p) and second column reports tbar*(p)                  **/
/*          for p=0,1,...,maxp in ascending order                       **/
/*     -tbar(p) statistic is defined as simple average of               **/
/*       adf(p)_i statistics                                            **/
/*     -tbar*(p) statistic is defined as simple average of              **/
/*       adf*(p)_i statistics, which is truncated version of adf(p)_i.  **/
/*    Notes: For a discussion about the truncation, See Pesaran (2006), **/
/*      " A Simple Panel Unit Root Test Under Cross Section Dependence" **/
/*                                                                      **/   
/* adf_p_mat: a N x (maxp+1) matrix, reports all ADF(p)_i statistics    **/   
/* adfs_p_mat: a N x (maxp+1) matrix, reports all ADF*(p)_i statistics  **/   
/* res_p_mat: a (maxp+1) set of						                    **/ 
/*		T-(maxp+1) x N matrix of residuals of  ADF(p)_i regressions	    **/
/*              concatenated vertically, from the top p=0,p=1,,,p=maxp  **/    
/*                                                                      **/   
/* IPS is sqrt(N)*(TBAR - E(TBAR))/sqrt(Var(TBAR)).                     **/
/* Appropriate E(TBAR) and Var(TBAR) are found in                       **/
/* Table 3 of Im,Pesaran,Shin (2003)                                    **/
/* NOTEs: Default setting is to print the results. It can be            **/
/*       suppressed by choosing "outpt=0" below (7th-line of the code   **/
/* Takashi Yamagata, 13 March 2006                                        **/
/*                                                                      **/
/*************************************************************************/
proc(4)=ips(var_mat,maxp,case);
local outpt,n,t,tlag,var_mat_1,Dvar_mat_temp,Dvar_mat;
local tt,y,z,x,xx,k1,k2,bvec,sevec,t_vec,t_bar,i,c_p,temp;
local trncl,truncu,trnc1,adf_p,adf_ps,tbar_p_mat,tbar_p,tbar_ps;
local adf_p_mat,adfs_p_mat,idvec,lgorder,res_p_mat,res_p;


/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outpt=1;/* 1: reports ourput, 0:supress the output */
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outwidth 256;

t=rows(var_mat);
n=cols(var_mat);
tlag=maxp+1;

var_mat_1=lag(var_mat);
Dvar_mat_temp=var_mat-var_mat_1;
    var_mat_1=var_mat_1[tlag+1:t,.];
    Dvar_mat=Dvar_mat_temp[tlag+1:t,.];

tt=t-tlag;

/*************/
y=vec(Dvar_mat);
x=vec(var_mat_1);

/****/
if case==1;k1=-6.12;k2=4.16;
elseif case==2;Z=ones(n*tt,1);k1=-6.19;k2=2.61;
elseif case==3;Z=ones(n*tt,1)~(ONES(N,1).*.seqa(1,1,tt));k1=-6.42;k2=1.70;
else;"please choose the 'case' only from 1,2, or 3";end;
endif;

/**************** ESTIMATION ****************/
c_p=0;
tbar_p_mat={};
adf_p_mat={};
adfs_p_mat={};
res_p_mat={};
do while c_p<=maxp;

if c_p>0;
    temp=(Dvar_mat_temp[tlag+1-c_p:t-c_p,.]);
    x=x~vec(temp);
endif;

/*************/
if case==1;xx=x;
else;xx=x~Z;
endif;

/*** MGCCE ****/
{bvec,sevec,t_vec,res_p}=mgsimple(y,xx,n,tt);

trncl=k1*(t_vec[.,1].<k1);truncu=k2*(t_vec[.,1].>k2);
trnc1=(t_vec[.,1].>k1).*(t_vec[.,1].<k2);

adf_p = t_vec[.,1];
adf_ps = (t_vec[.,1].*trnc1+trncl+truncu);

tbar_p=meanc(adf_p);
tbar_ps=meanc(adf_ps);

if outpt==1;
format /rd 2,0;
"@@@@@@@@@@@@@@@@@@@ ADF(";;C_P;;") @@@@@@@@@@@@@@@@@@@@";
format /rd 2,0;
"tbar STATISTIC FOR IPS(P): CASE";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 5,0;
"N=";;n;;", T=";;tt;;", (";;t;;"data points used)";
format /rd 8,3;
"   TBAR(P)            :";;tbar_p;
"   TBAR(P)*(truncated):";;tbar_ps;
format /rd 1,2;
"*Truncation is done for ADF_i in such a way that";
"when ADF_i<k1, ADF_i=k1 and when ADF_i>k2, ADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
"IPS is sqrt(N)*(TBAR - E(TBAR))/sqrt(Var(TBAR)).";
"Appropriate E(TBAR) and Var(TBAR) are found in Table 3 of Im,Pesaran,Shin (2003).";
"-------------------------------------------------------";
"";
endif;
tbar_p_mat=tbar_p_mat|(tbar_p~tbar_ps);
adf_p_mat=adf_p_mat~adf_p;
adfs_p_mat=adfs_p_mat~adf_ps;
res_p_mat=res_p_mat|res_p;

    c_p=c_p+1;
endo;

if outpt==1;
format /rd 8,0;
idvec=ftocv(seqa(1,1,n),1,0);
lgorder="id/p"~ftocv(seqa(0,1,maxp+1)',1,0);

format /rd 2,0;
"";
"*****************************************************";
"ADF_i(p) Statistics: Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT AND TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(adf_p_mat,1,3)));
"";
"*****************************************************";
format /rd 2,0;
"ADF*_i(p) Statistics (truncated): Case";;case;;
if case==1;", NO INTERCEPT";
elseif case==2;", WITH INTERCEPT";
elseif case==3;", WITH INTERCEPT and TREND";
endif;
format /rd 8,0;
$ (lgorder|(idvec~ftocv(adfs_p_mat,1,3)));
format /rd 1,2;
"*Truncation is done for ADF_i in such a way that";
"when ADF_i<k1, ADF_i=k1 and when ADF_i>k2, ADF_i=k2,";
"where ";;"k1=";;k1;;" and k2=";;k2;;".";
endif;

format /rd 16,8;
retp(tbar_p_mat,adf_p_mat,adfs_p_mat,res_p_mat);
endp;

/*** OLS regression for each cross section unit ****/
proc(4)=mgsimple(y,x,n,t);
local bvec,sevec,tvec,i,y_i,x_i,beta_i,e_i,zig2,se_i,t_i,res_mat;
bvec=zeros(n,cols(x));
sevec=zeros(n,cols(x));
tvec=zeros(n,cols(x));
res_mat={};
i=1;
do while i<=n;
    y_i=y[1+(i-1)*t:(i)*t,.];
    x_i=x[1+(i-1)*t:(i)*t,.];
    beta_i=y_i/x_i;
    e_i=y_i-x_i*beta_i;
    zig2=e_i'e_i/(T-cols(x));
    se_i=sqrt(diag(zig2*invpd(x_i'x_i)));
    t_i=beta_i./se_i;

    bvec[i,.]=beta_i';
    sevec[i,.]=se_i';
    tvec[i,.]=t_i';
    res_mat=res_mat~e_i;

i=i+1;
endo;

retp(bvec,sevec,tvec,res_mat);
endp;

/***********************************************************************************************/

/********************************************************************/
/* This is a gauss procedure to compute Moon and Perron (2004),     */
/* "TESTING FOR A UNIT ROOT IN PANELS WITH DYNAMIC FACTORS",        */
/* Journal of Econometrics 122, 81-126.                             */
/*                                                                  */
/* This code is heavily based on the Matlab code by                 */
/* Moon & Perron 2004, last updated June 25 2004.                   */
/*								                                    */
/* {testvec}=PU_MP04(y,m,case);	                                    */
/*                                                                  */
/*  <<INPUT>>                                                       */
/*  y: (T+1 x N) matrix                                             */
/*  m: number of factors (estimated beforehand or known)            */
/*  case:  1 or 2: fixed effects no trend, or 3: deterministic trend*/
/*                                                                  */
/*  <<OUTPUT>>                                                      */
/*  testvec: a (3 x 1) vector, (m,tstara,tstarb)'                   */
/*          tstara and tstarb are defined in p.92 for case 1 & 2.   */
/*                                                                  */
/*  NB:This code uses Andrews and Monahan (1992) bandwidth estimator*/
/* NOTEs: Default setting is to print the results. It can be        */
/*       suppressed by choosing "outpt=0" below                     */
/*  Takashi Yamagata, 6 March 06                                    */
/********************************************************************/


proc(1)=PU_MP04(x_mat,m,case);
local outpt,n,t,al,p,y_mat,y_1_mat,z,x1,qx,ztilde,ztildet,ztildel,rhohat,yhat;
local values,vectors,zqbeta,zqbetal,resid,sigmas,sigmasq,omega;
local lambda1,matj1,omegas,omegasq,matj2,lambda,phi4;
local zq,zql,rhostar,hatrho,nt,tstara,tstarb,testvec;

/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outpt=1;/* 1: reports ourput, 0:supress the output */
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
outwidth 256;

z=x_mat;
n=cols(z);
t=rows(z)-1;

    if case==1 or case==2;
    
    al = 0;    /* a1=0 implies no trend*/
    p = -1;    /* no deterministic component estimated  */ 
    
    elseif case == 3;
        al = 1;  /* linear trend*/
        p = 1;   /* trend estimated*/
    endif;    
    
              /*remove deterministic components*/
        
        if p == 0; 
            x1 = ones(t+1,1);
            qx = eye(t+1)-x1*x1'/(t+1);
        elseif p == 1;
            x1 = ones(t+1,1)~seqa(1,1,t+1);
            qx = eye(t+1)-x1*inv(x1'*x1)*x1';
        elseif p == -1;
            qx = eye(t+1);  
        endif;

        ztilde = qx*z;        
        ztildet = ztilde[2:t+1,.];
        ztildel = ztilde[1:t,.];        
        
        rhohat = tr(ztildel*ztildet')/tr(ztildel*ztildel');
        yhat = ztildet-rhohat*ztildel;       
        
        /*extract factors using normalization with smaller dimension*/
    
        if n <= t;
            {values,vectors} = eighv(yhat'*yhat);              
        else;        
            {values,vectors} = eighv(yhat*yhat');     
        endif;
        
/* number of factors should be given as "m"
*/       
            /*compute FM estimator*/

            zqbeta = ortho(ztildet,yhat,vectors,m);      /* project ztilde onto orthogonal space */
            zqbetal = ortho(ztildel,yhat,vectors,m);     
            
            resid = zqbeta-rhohat*zqbetal;
        
            /*compute variance of errors*/
        
            sigmas = sumc(abs(resid).^2)/t;
            sigmasq = sumc(sigmas)/n;
                        
            /*compute long-run covariances*/
            
            /*(bandwidth selection based on Andrews and Monahan 1992 */  
            omega=zeros(n,1);lambda1=zeros(n,1);                   
            for j (1,n,1);
                {matj1,matj2} = lrcov(resid[.,j],1,999);                
                omega[j]=matj1;
                lambda1[j]=matj2;
            endfor;            
            omegas = omega;
            omegasq = meanc(omegas);
            lambda = 0.5*(omegasq - sigmasq);
            phi4 = (omegas'*omegas)/n;            
                
            zq = zqbetal*zqbeta';        
            zql = zqbetal*zqbetal';        
            
            /* autoregressive parameter - rhostar with estimated variances */        
            
            if p == -1 or p==0; 
                rhostar = (tr(zq)-n*t*meanc(diag(lambda)))/tr(zql); 
            elseif p==1;
                rhostar = (tr(zq)+0.5*n*t*meanc(sigmas))/tr(zql);
            endif;

            /*compute test statistics*/
            
            NT = sqrt(n)*t;
            if p == -1 or p==0;
                tstara = NT*(rhostar-1)/sqrt(2*phi4/omegasq^2);
                tstarb = NT*(rhostar-1)*sqrt(tr(zql)/(n*t^2))*sqrt(omegasq/phi4);    
            elseif p == 1;
                tstara = NT*(rhostar-1)/sqrt((15/4)*phi4/omegasq^2);
                tstarb = NT*(rhostar-1)*sqrt(tr(zql)/(n*t^2))*sqrt(4*omegasq/phi4);
            endif;  
testvec=(m|tstara|tstarb);

/**/
if outpt==1;
"";
"MOON AND PERRON (2004) PANEL UNIT ROOT TEST RESULTS";
if case==1 or case==2;
"In the case without trend";
elseif case==3;
"In the case with trend";
endif;
format /rd 4,0;
"";
"N=";;n;
"Number of data points used:";;t+1;;"(T = ";;t;;")";
"Given number of factors:";;m;
"";
format /rd 10,3;
"tstar_a";;tstara;
"tstar_b";;tstarb;
"------------------------------------------------";
endif;
retp(testvec);
endp;     




/***********************************************************************/
/*************   PROCEDURES ********************************************/
/***********************************************************************/

proc(1)=tr(x);
local tr;
tr=sumc(diag(x));
retp(tr);
endp;

proc(2) = LRcov(x,wght,mtd);
local t,n,xt,xl,sigma,a,v,d,i,xpw,omega,b,resid,s_resid,s4,wght1;
local s_deux,s_zero,delta,l,lambda,j,gama,w,qs,dinv;

t=rows(x);n=cols(x);
if n==1;
wght1=wght;
else;
wght1=wght|ones(n-1,1);
endif;
/*prewhitening*/

sigma = x'*x/t;

xt = x[2:t,.];
xl = x[1:t-1,.];

a = xt'*xl*inv(xl'*xl);
{d,v} = eighv(a);
for i (1,n,1);
    if (d[i,i]>0.97) or (d[i,i]<-0.97);
        d[i,i] = 0.97*(2*(d[i,i].>1)-1);
    endif;
endfor;
a = v*d*inv(v);

xpw = xt - xl*a';

omega = xpw'*xpw/t;

/*------------------*/
if mtd==999;
    /* Andrews*/
    xt = xpw[2:t-1,.];
    xl = xpw[1:t-2,.];
    b = diag((xt'*xl)./(xl'*xl));
    Resid = xt-xl*diag(b);        
    s_resid = Resid'*Resid/t;
    s4 = diag(s_resid)^2;
    
    s_deux = (4*((b)^2)*s4/((1-b)^8));
    s_zero = ( s4 ./ ((1-b).^4)); 
    delta = 1.3221*((wght1'*(s_deux))/(wght1'*(s_zero))).^(0.2);
    
endif;
/*---------------*/
L = delta*t^(0.2);

lambda = 0;
for j (1,t-2,1);
    gama = xpw[j+1:t-1,.]'*xpw[1:t-j-1,.]/t;
    v=j/L;
    w=6*pi*v/5;        
    qs=((25./(12*((pi*v).^2))).*(((sin(w))./w)-cos(w)));
    omega = omega + qs*(gama + gama');
    lambda = lambda +qs*gama;
    
endfor;

/* recolor */

dinv = inv(eye(n)-a);
omega = dinv*omega*dinv';
lambda = dinv*lambda*dinv' + sigma*a'*dinv';

retp (omega,lambda);
endp;


proc(1) = ortho(y,yhat,v,k);
local t,n,loadings,factors,betahat,norm,qbeta,x;

t=rows(y);n=cols(y);

if n <= t;
    loadings=sqrt(n)*v[.,n-k+1:n];
    factors=yhat*loadings/n;
    betahat=(yhat'*yhat)*loadings/(n*t);
else;
    factors=sqrt(t)*v[.,t-k+1:t];
    loadings=yhat'*factors/t;
    norm=loadings'*loadings/n;
    betahat=loadings*chol(norm);
endif;

qbeta=eye(n)-betahat*inv(betahat'*betahat)*betahat';

x = y*qbeta;

retp(x);
endp;

